问： JS 中使用 typeof 能得到哪些类型  
考点：JS 变量类型
问： 何时使用 === 何时使用 == 
考点：强制类型转换
问： window.onload and DOMContentLoaded 的区别
考点：浏览器的渲染过程
问： 用 JS 创建 10 个 <a> 标签，点击的时候弹出来对应的序号 
考点：作用域
问： 简述如何实现一个模块加载器，实现类似 require.js  的基本功能
考点：JS 模块化
问： 实现数组的随机排序，
考点：js 的基础算法

变量的类型和计算   
问：JS 中使用 typeof 能得到哪些类型

问：何时使用 === 何时使用 == 

问：JS 中有那些内置函数

问：JS 变量按照存储方式分为哪些类型，并描述其特点

问：如何理解 JSON

变量类型
1 值类型和引用类型
2 变量计算
var c = {age:21}
var d = c
d.age = 22
console.log(c)//22  
在这段代码中，对象 {age:21} 是存在一个特定的地方，而 C 通过指针指向了 对象 {age:21} 的地址。当 b=a 的时候就是把 b 的指针也指向；了 {age:21} 这个对象，当写第三行的时候 {age:21} 对象的位置已经发生了变化，age不再是21了而是22了
常用的引用类型包括 对象 数组 函数

typeof 
typeof 可以区分出 undefined string number Boolean 这四个是值类型的详细类型，但是他不能区分引用类型的对象。数组 对象 以及比较特殊的 null,函数是一个非常特殊的引用类型，他可以区分成为 function 

变量计算     
强制类型的转换             
字符串拼接     
== 运算符     
if语句     
逻辑运算      

原型和原型链

问：怎么准确判断一个变量是数组类型

问：写一个原型链的继承的例子

问：描 new 一个对象的过程
首先会创建一个新的对象，然后 this 指向这个新的对象，然后把 this 清空，然后执行代码对 this 赋值，然后返回
问：zepto 或者其他框架源码中如何使用原型链
建议去阅读作者写的 zepto 的课程。“zepto 设计和源码分析”
知识点：
构造函数：
构造函数-扩展：
原型规则和示例：
原型链：
instanceof：

构造函数：
在定义构造函数的时候一般约定俗成的就是让函数名以大写开头，这样就知道这是一个构造函数了，
function Foo(age,name) {
  this.age = age
  this.name = name
  this.class = 'class-1'
  //return this //默认有这一行
}
这其中的 this.age = age 这几行就是一个定义赋值的行为，这行为中最初的值都是空值，而在 ES6 中新增加了默认的模板赋值，会添加一个默认的值。而在这里是没有的

var f = new Foo('zhangsan',20)  这一行代码就表示这是一个实例的过程，这时候就把 zhangsan 20 赋值给了 name 和 age 这时候的 this 其实是空的。这个构造函数的存在就相当于一个模板一样的存在，可以用这个模板构造出很多个类型一样但是内容不一样的函数。在 new 之前构造函数中的 this 会变成一个空对象，然后再把相关的数据传进去

构造函数扩展
var a = {} 其实是 var a = new Object() 的语法糖
var a = [] 其实是 var a = new Array() 的语法糖
function Foo(){...} 其实是 var Foo = new Function() 的语法糖

使用 instanceof 判断一个函数是否是一个变量的构造函数

## 原型规则和示例   
所有的引用类型（数组，对象，函数）都具有对象特性，即可自由扩展属性（除了 “null” 以外）
所有的引用类型（数组，对象，函数）都具有 __proto__ （隐式原型）属性，属性值是一个普通的对象
所有的函数都有一个 prototype 属性（显式原型）属性值也是一个普通的对象
所有的引用类型（数组，对象，函数），__proto__ 属性值都指向它的构造函数的 'prototype' 属性值
当试图得到一个对象的某个属性时候，如果这个对象本身没有这个属性就会去她的隐式原型 __proto__ 也就是她的构造函数的 prototype 中寻找

## 原型链
所谓的原型链就是当我们定义了一个 Foo 构造函数，通过 prototype 的方式添加了一个属性，当我们通过f = new Foo 来新建一个函数的时候，这个函数 f 他的隐式原型就是 Foo 的显示原型，也就是我们通过 prototype 添加的那个属性，当我们想要查看一个函数的一个属性的时候，如果在 f 的隐式原型上没有，也就是该函数的显示原型上也没有的时候，这时候就去查找该函数的显示原型的隐式原型，这样一层一层的查找，直到最后查到 null 为止



第三节 作用域和闭包

fn()
function fn() {}

和 

fn1()
var fn1 = function() {}
有什么区别？？

1 说一下对变量提升的理解
2 说明一下 this 的几种不同的使用场景
3 创建 10 个 <a> 标签，点击的时候弹出来对应的序号
4 如何理解作用域 
5 实际开发中闭包的应用





