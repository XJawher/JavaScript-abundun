问： JS 中使用 typeof 能得到哪些类型  
考点：JS 变量类型
问： 何时使用 === 何时使用 == 
考点：强制类型转换
问： window.onload and DOMContentLoaded 的区别
考点：浏览器的渲染过程
问： 用 JS 创建 10 个 <a> 标签，点击的时候弹出来对应的序号 
考点：作用域
问： 简述如何实现一个模块加载器，实现类似 require.js  的基本功能
考点：JS 模块化
问： 实现数组的随机排序，
考点：js 的基础算法

变量的类型和计算   
问：JS 中使用 typeof 能得到哪些类型

问：何时使用 === 何时使用 == 

问：JS 中有那些内置函数

问：JS 变量按照存储方式分为哪些类型，并描述其特点

问：如何理解 JSON

变量类型
1 值类型和引用类型
2 变量计算
var c = {age:21}
var d = c
d.age = 22
console.log(c)//22  
在这段代码中，对象 {age:21} 是存在一个特定的地方，而 C 通过指针指向了 对象 {age:21} 的地址。当 b=a 的时候就是把 b 的指针也指向；了 {age:21} 这个对象，当写第三行的时候 {age:21} 对象的位置已经发生了变化，age不再是21了而是22了
常用的引用类型包括 对象 数组 函数

typeof 
typeof 可以区分出 undefined string number Boolean 这四个是值类型的详细类型，但是他不能区分引用类型的对象。数组 对象 以及比较特殊的 null,函数是一个非常特殊的引用类型，他可以区分成为 function 

变量计算     
强制类型的转换             
字符串拼接     
== 运算符     
if语句     
逻辑运算      

原型和原型链

问：怎么准确判断一个变量是数组类型

问：写一个原型链的继承的例子

问：描 new 一个对象的过程
首先会创建一个新的对象，然后 this 指向这个新的对象，然后把 this 清空，然后执行代码对 this 赋值，然后返回
问：zepto 或者其他框架源码中如何使用原型链
建议去阅读作者写的 zepto 的课程。“zepto 设计和源码分析”
知识点：
构造函数：
构造函数-扩展：
原型规则和示例：
原型链：
instanceof：

构造函数：
在定义构造函数的时候一般约定俗成的就是让函数名以大写开头，这样就知道这是一个构造函数了，
function Foo(age,name) {
  this.age = age
  this.name = name
  this.class = 'class-1'
  //return this //默认有这一行
}
这其中的 this.age = age 这几行就是一个定义赋值的行为，这行为中最初的值都是空值，而在 ES6 中新增加了默认的模板赋值，会添加一个默认的值。而在这里是没有的

var f = new Foo('zhangsan',20)  这一行代码就表示这是一个实例的过程，这时候就把 zhangsan 20 赋值给了 name 和 age 这时候的 this 其实是空的。这个构造函数的存在就相当于一个模板一样的存在，可以用这个模板构造出很多个类型一样但是内容不一样的函数。在 new 之前构造函数中的 this 会变成一个空对象，然后再把相关的数据传进去

构造函数扩展
var a = {} 其实是 var a = new Object() 的语法糖
var a = [] 其实是 var a = new Array() 的语法糖
function Foo(){...} 其实是 var Foo = new Function() 的语法糖

使用 instanceof 判断一个函数是否是一个变量的构造函数

## 原型规则和示例   
所有的引用类型（数组，对象，函数）都具有对象特性，即可自由扩展属性（除了 “null” 以外）
所有的引用类型（数组，对象，函数）都具有 __proto__ （隐式原型）属性，属性值是一个普通的对象
所有的函数都有一个 prototype 属性（显式原型）属性值也是一个普通的对象
所有的引用类型（数组，对象，函数），__proto__ 属性值都指向它的构造函数的 'prototype' 属性值
当试图得到一个对象的某个属性时候，如果这个对象本身没有这个属性就会去她的隐式原型 __proto__ 也就是她的构造函数的 prototype 中寻找

## 原型链
所谓的原型链就是当我们定义了一个 Foo 构造函数，通过 prototype 的方式添加了一个属性，当我们通过f = new Foo 来新建一个函数的时候，这个函数 f 他的隐式原型就是 Foo 的显示原型，也就是我们通过 prototype 添加的那个属性，当我们想要查看一个函数的一个属性的时候，如果在 f 的隐式原型上没有，也就是该函数的显示原型上也没有的时候，这时候就去查找该函数的显示原型的隐式原型，这样一层一层的查找，直到最后查到 null 为止



第三节 作用域和闭包

fn()
function fn() {}

和 

fn1()
var fn1 = function() {}
有什么区别？？

1 说一下对变量提升的理解
变量的定义和函数的声明


2 说明一下 this 的几种不同的使用场景
作为构造函数
作为对象
作为普通的函数

3 创建 10 个 <a> 标签，点击的时候弹出来对应的序号
4 如何理解作用域 
5 实际开发中闭包的应用

作用域的知识点：
1 执行上下文 
范围：分为一段 <script> 标签内和一个函数内的执行上下文，也就是这两个都是会生成一个独自的执行上下文环境
全局：针对 <script> 他首先会生成一个全局的执行上下文，他在执行之前会先把变量声明和函数声明先拿出来。
函数执行上下文：针对函数，函数就是会生成一个函数执行上下文，这时候就会在函数执行之前把 变量定义，函数声明，this arguments 拿出来。

2 this
this 要在执行的时候才能确定值，在定义的时候是无法确认值的。
1>作为构造函数执行



2>作为对象属性执行
3>作为普通函数执行
4>call apply bind

3 作用域
1> 全局作用域
2> 函数作用域



4 作用域链
5 闭包
闭包的使用场景
1>函数作为返回值
2>函数作为参数传递
实际开发中闭包的应用：
主要用于封装变量，收敛权限

## 异步和单线程
问：异步和同步的区别是什么？？
异步和同步的最大的区别就是同步要按照顺序来执行，有存在阻塞的现象，异步会把阻塞先放掉，然后执行完以后再做阻塞的事件，同步就是告诉我什么时间做什么事情，异步就是我做我的，做完了再搞你告诉我的事件
什么时候需要异步？、
在可能发生等待的情况，不能说在等待的过程中什么事情都不做，这样就发生了阻塞事件了。
在等待的过程中不能像 alert 一样阻塞程序运行，等待的情况需要异步

问：一个关于 setTimeOut 的笔试题
问：前端使用异步的场景有那些
setTimeOut setInerval 定时任务，设定多少秒以后做事件，网络请求：ajax 请求 动态 <img> 加载。事件绑定：用户什么时候点我们不知道，不能因为用户不点击就不做事件，该干嘛还是要干嘛，让程序做该做的事件，用户点击了就用异步，什么时候点击不需要管。
知识点：
什么是异步？？
前端使用异步的场景

异步和单线程的区别




其他知识点：
日期，math 数组API 对象 API

## 从基础知识到 JS-web-api

## DOM 文档对象模型
问：DOM 是那种基本的数据结构


问：DOM 操作的常用结构

问：DOM 节点的 attribute 和 property 有啥区别
property 是 JS 对象的属性 比如 var obj = {x:100,y:200} obj.x = 100, 这儿的 obj.x 中的 X 就是一个 property 
attribute 修改的是 HTML 文档的标签中的属性



DOM 的本质是什么？？
节点树，结构化，能让 JS 可识别可操作性
DOM 节点操作
获取 DOM 节点 以 getElementById 为类型的 api 





DOM 结构操作
新增节点
有两种方法，一个是 
var div1 = document.getElementById('div1')
// add new node 
var p1 = document.createElement('p')
p.innerHTML = 'this is p '
//移动新的节点
var p2 = document.getElementById('p2')
div1.appendChild(p2)



获取父子元素
删除节点









